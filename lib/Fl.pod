class 'Fl';
include 'FL/Fl.H';

=pod

=encoding utf-8

=head1 NAME

Fl - Bindings for the Stable 1.3.x Branch of the Fast Light Toolkit

=head1 SYNOPSIS

    use Fl qw[:event :label :box :font];
    my $window = Fl::Window->new(100, 100, 300, 180);
    my $box = Fl::Box->new(FL_UP_BOX, 20, 40, 260, 100, 'Hello, World');
    $box->labelfont(FL_BOLD + FL_ITALIC);
    $box->labelsize(36);
    $box->labeltype(FL_SHADOW_LABEL);
    $window->end();
    $window->show();
    exit run();

=head1 DESCRIPTION

The Fl distribution includes bindings to the stable 1.3.x branch of the Fast
Light Toolkit; a cross-platform GUI toolkit compatible with Microsoft Windows,
MacOS X, and Linux/Unix platforms with X11. It was designed to be small, quick
and comes with a very simple yet complete API.

=head1 Common Widgets and Attributes

Many widgets come with Fl but we'll cover just the basics here.

=head2 Buttons

Fl provides many types of buttons:

=for html <center><img src="http://www.fltk.org/doc-1.3/buttons.png" /></center>

=over

=item L<Fl::Button> - A standard push button

=item L<Fl::CheckButton> - A button with a check box

=item L<Fl::LightButton> - A push buton with a light

=item L<Fl::RepeatButton> - A push button that continues to trigger its callback when held

=item L<Fl::ReturnButton> - A push button that is activated by the Enter key

=item L<Fl::RoundButton> - A button with a radio circle (See also L<Fl::RadioRoundButton>)

=back

The constructor for all of these buttons takes the bounding box of the button
and an optional label string:

    my $fl_btn = Fl::Button->new($x, $y, $width, $height, "label");
    my $fl_lbtn = Fl::LightButton->new($x, $y, $width, $height);
    my $fl_rbtn = Fl::RoundButton->new($x, $y, $width, $height, "label");

Each button has an associated C<type()> which allows it to behave as a push
button, toggle button, or radio button.

    $fl_btn->type(FL_NORMAL_BUTTON);
    $fl_lbtn->type(FL_TOGGLE_BUTTON);
    $fl_rbtn->type(FL_RADIO_BUTTON);

For toggle and radio buttons, the C<value()> method returns the current button
state (0 = off, 1 = on). The C<set()> and C<clear()> methods can be used on
toggle buttons to turn it on or off. Radio buttons can be turned on with the
C<setonly()> method; this will also turn off other radio buttons in the same
group.

=head1 Box Types

=for html <center><img src="http://www.fltk.org/doc-1.3/boxtypes.png" /></center>

Widgets are drawn on screen according to their box types. The full list of
these may be found in L<Fl::Enumerations/":box"> and may be imported into your
namespace with the C<:box> tag.

FL_NO_BOX means nothing is drawn at all, so whatever is already on the screen
remains. The FL_..._FRAME types only draw their edges, leaving the interior
unchanged.

=head1 Labels and Label Types

The C<label()>, C<align()>, C<labelfont()>, C<lablesize()>, C<labeltype()>,
C<image()>, and C<deimage()> methods control labeling of widgets.

=head2 C<label()>

The C<label()> method sets the string that is displayed for hte label. Symbols
can be included withthe label string by escaping them with the C<@> symbol.
C<@@> displays a single at symbol.

=for html <center><img src="http://www.fltk.org/doc-1.3/symbols.png" /></center>

The C<@> sign may also be followed by the following optional "formatting"
characters, in this order:

=over

=item '#' forces square scaling, rather than distortion to the widget's shape.

=item +[1-9] or -[1-9] tweaks the scaling a little bigger or smaller.

=item '$' flips the symbol horizontally, '%' flips it vertically.

=item [0-9] - rotates by a multiple of 45 degrees. '5' and '6' do no rotation
while the others point in the direction of that key on a numeric keypad. '0',
followed by four more digits rotates the symbol by that amount in degrees.

=back

Thus, to show a very large arrow pointing downward you would use the label
string "@+92->".

=head2 C<align()>

The C<align()> method positions the label. The following constants are imported
with the C<:align> tag and may be OR'd together as needed:

=over

=item FL_ALIGN_CENTER - center the label in the widget.

=item FL_ALIGN_TOP - align the label at the top of the widget.

=item FL_ALIGN_BOTTOM - align the label at the bottom of the widget.

=item FL_ALIGN_LEFT - align the label to the left of the widget.

=item FL_ALIGN_RIGHT - align the label to the right of the widget.

=item FL_ALIGN_LEFT_TOP - The label appears to the left of the widget, aligned
at the top. Outside labels only.

=item FL_ALIGN_RIGHT_TOP - The label appears to the right of the widget,
aligned at the top. Outside labels only.

=item FL_ALIGN_LEFT_BOTTOM - The label appears to the left of the widget,
aligned at the bottom. Outside labels only.

=item FL_ALIGN_RIGHT_BOTTOM - The label appears to the right of the widget,
aligned at the bottom. Outside labels only.

=item FL_ALIGN_INSIDE - align the label inside the widget.

=item FL_ALIGN_CLIP - clip the label to the widget's bounding box.

=item FL_ALIGN_WRAP - wrap the label text as needed.

=item FL_ALIGN_TEXT_OVER_IMAGE - show the label text over the image.

=item FL_ALIGN_IMAGE_OVER_TEXT - show the label image over the text (default).

=item FL_ALIGN_IMAGE_NEXT_TO_TEXT - The image will appear to the left of the text.

=item FL_ALIGN_TEXT_NEXT_TO_IMAGE - The image will appear to the right of the text.

=item FL_ALIGN_IMAGE_BACKDROP - The image will be used as a background for the widget.

=back

Please see the L<:align|Fl::Enumerations/":align"> tag for more.

=head2 C<labeltype()>

The C<labeltype()> method sets the type of the label. The following standard
label types are included:

=over

=item FL_NORMAL_LABEL - draws the text.

=item FL_NO_LABEL - does nothing.

=item FL_SHADOW_LABEL - draws a drop shadow under the text.

=item FL_ENGRAVED_LABEL - draws edges as though the text is engraved.

=item FL_EMBOSSED_LABEL - draws edges as thought the text is raised.

=item FL_ICON_LABEL - draws the icon associated with the text.

=back

These are imported with the C<:label> tag. Please see
L<Fl::Enumerations|Fl::Enumerations/":label"> for more.

=head1 Callbacks

Callbacks are functions that are called when the value of a widget is changed.
A callback function is sent the widget's pointer and the data you provided.

    sub xyz_callback {
        my ($widget, $data) = @_;
        ...
    }

The C<callback(...)> method sets the callback function for a widget. You can
optionally pass data needed for the callback:

    my $xyz_data = 'Fire Kingdom';
    $button->callback(&xyz_callback, $xyz_data);

You can also pass an anonymous sub to the C<callback(...)> method:

    $button->callback(sub { warn 'Click!' });

Normally, callbacks are performed only when the value of the widget changes.
You can change this using the L<when()|Fl::Widget/when(...)> method:

    $button->when(FL_WHEN_NEVER);
    $button->when(FL_WHEN_CHANGED);
    $button->when(FL_WHEN_RELEASE);
    $button->when(FL_WHEN_RELEASE_ALWAYS);
    $button->when(FL_WHEN_ENTER_KEY);
    $button->when(FL_WHEN_ENTER_KEY_ALWAYS);
    $button->when(FL_WHEN_CHANGED | FL_WHEN_NOT_CHANGED);

These values may be imported with the C<:when> tag. Please see
L<Fl::Enumerations|Fl::Enumerations/":when"> for more.

A word of caution: care has been taken not to tip over when you delete a widget
inside it's own callback but it's still not the best idea so...

    $button->callback(
        sub {
            $button = undef; # Might be okay. Might implode.
        }
    );

Eventually, I'll provide an explicit C<delete_widget()> method that will mark
the widget for deletion when it's safe to do so.

=head1 Shortcuts

Shortcuts are key sequences that activate widgets such as buttons or menu
items. The C<shortcut(...)> method sets the shortcut for a widget:

    $button->shortcut(FL_Enter);
    $button->shortcut(FL_SHIFT + 'b');
    $button->shortcut(FL_CTRL + 'b');
    $button->shortcut(FL_ALT + 'b');
    $button->shortcut(FL_CTRL + FL_ALT + 'b');
    $button->shortcut(0); # no shortcut

The shortcut value is the key event value - the ASCII value or one of the
special keys described in L<Fl::Enumerations|Fl::Enumerations/":keyboard">
combined with any modifiers like Shift, Alt, and Control.

These values may be imported with the C<:keyboard> tag. Please see
L<Fl::Enumerations|Fl::Enumerations/":keyboard"> for an expansive lis
=head1 Other Classes

Fl contains several other widgets and other classes including:

=over

=item L<Fl::Box>

=item L<Fl::Input> - Simple text input widget

=item L<Fl::SecretInput> - Think 'password field'

=item L<Fl::FloatInput>

=item L<Fl::IntInput>

=item L<Fl::Chart>

=item L<Fl::Valuator>

=item L<Fl::Adjuster>

=item L<Fl::Group>

=item L<Fl::Window>

=back

This is the current list and will expand as the distribution develops.

=for todo http://www.fltk.org/doc-1.3/common.html


=head1 Enumerations

You may import these constants by name or with the given tag.

=head2 C<:option>

These constants define values which can effect how the application functions.

They are used by C<Fl::option( ... )>

=over

=item C<OPTION_ARROW_FOCUS>

When switched on, moving the text cursor beyond the start or end of a text in a
text widget will change focus to the next text widget.

(This is considered 'old' behavior)

When switched off (default), the cursor will stop at the end of the text.
Pressing Tab or Ctrl-Tab will advance the keyboard focus.

=item C<OPTION_VISIBLE_FOCUS>

If visible focus is switched on (default), FLTK will draw a dotted rectangle
inside the widget that will receive the next keystroke.

If switched off, no such indicator will be drawn and keyboard navigation is
disabled.

=item C<OPTION_DND_TEXT>

If text drag-and-drop is enabled (default), the user can select and drag text
from any text widget.

If disabled, no dragging is possible, however dropping text from other
applications still works.

=item C<OPTION_SHOW_TOOLTIPS>

If tooltips are enabled (default), hovering the mouse over a widget with a
tooltip text will open a little tooltip window until the mouse leaves the
widget.

If disabled, no tooltip is shown.

=item C<OPTION_FNFC_USES_GTK>

When switched on (default), C<Fl::NativeFileChooser> runs GTK file dialogs if
the GTK library is available on the platform (linux/unix only).

When switched off, GTK file dialogs aren't used even if the GTK library is
available.

=item C<OPTION_LAST>

For internal use only.

=back

=cut

export_constant("Fl::OPTION_ARROW_FOCUS",   "option");
export_constant("Fl::OPTION_VISIBLE_FOCUS", "option");
export_constant("Fl::OPTION_DND_TEXT",      "option");
export_constant("Fl::OPTION_SHOW_TOOLTIPS", "option");
export_constant("Fl::OPTION_FNFC_USES_GTK", "option");
export_constant("Fl::OPTION_LAST",          "option");
test tag_option => sub {
    can_ok('Fl', 'OPTION_ARROW_FOCUS');
    can_ok('Fl', 'OPTION_VISIBLE_FOCUS');
    can_ok('Fl', 'OPTION_DND_TEXT');
    can_ok('Fl', 'OPTION_SHOW_TOOLTIPS');
    can_ok('Fl', 'OPTION_FNFC_USES_GTK');
    can_ok('Fl', 'OPTION_LAST');
};

=head1 Functions

The Fl namespace containins state information and global methods for the
current application.

=head2 C<abi_check( [...] )>

	abi_check( FL_ABI_VERSION );

Returns whether the runtime library ABI version is correct.

This enables you to check the ABI version of the linked FLTK library at
runtime.

Returns 1 (true) if the compiled ABI version (in the header files) and the
linked library ABI version (used at runtime) are the same, 0 (false) otherwise.

	abi_check( 10303 );

Argument C<$val> can be used to query a particular library ABI version. Use for
instance C<10303> to query if the runtime library is compatible with FLTK ABI
version C<1.3.3>. This is rarely useful.

	abi_check( );

The default C<$val> argument is C<FL_ABI_VERSION>, which checks the version
defined at configure time (i.e. in the header files at program compilation
time) against the linked library version used at runtime. This is particularly
useful if you linked with a shared object library, but it also concerns static
linking.

=cut

xs {name        => 'Fl::abi_check',
    definitions => [{required => [['int', 'val']], returns => 'int'},
                    {returns  => 'int'}
    ],
    export => ['all']
};
test abi_check => sub {
    ok(!abi_check(FL_ABI_VERSION - 1),
        'abi_check( FL_ABI_VERSION - 1 ) == !1');
    ok(abi_check(),               'abi_check( ) == 1');
    ok(abi_check(FL_ABI_VERSION), 'abi_check( FL_ABI_VERSION ) == 1');
};

=head2 C<abi_version( )>

	abi_version( );

Returns the compiled-in value of the C<FL_ABI_VERSION> constant.

This is useful for checking the version of a shared library.

=cut

xs {name        => 'Fl::abi_version',
    definitions => [{returns => 'int'}],
    export      => ['all']
};
test abi_version => sub {
    is(abi_version(), Fl::FL_ABI_VERSION, 'abi_version( ) == FL_ABI_VERSION');
};

=head2 C<add_awake_handler_( ... )>

	add_awake_handler_( sub { warn 'awake! }  );

Adds an awake handler for use in C<Fl::awake()>.

	add_awake_handler_( sub { warn 'awake! }, $data  );

You may also store userdata which will be passed along to the callback.

=cut

xs {name        => 'Fl::add_awake_handler_',
    definitions => [
                  {required => [['SV *', 'coderef'], ['SV *', 'userdata']],
                   returns  => 'int',
                   c_args => '_cb, (void *) new Callback( coderef, userdata )'
                  },
                  {required => [['SV *', 'coderef']],
                   returns  => 'int',
                   c_args   => '_cb, (void *) new Callback( coderef )'
                  }
    ],
    export => ['all']
};
test add_awake_handler_ => sub {
    diag(add_awake_handler_(sub { diag('TEST') }, {test => 'data'}));

#ok (add_awake_handler_( sub {...} ), 'add_awake_handler_(sub { ... })');
#ok (add_awake_handler_( sub {...}, {some => 'data'} ), 'add_awake_handler_(sub { ... }, { some => "data" })');
    diag(awake());
    ok(1);
};

=head2 C<add_check( ... )>

	add_check( sub { warn 'awake! }  );

FLTK will call this callback just before it flushes the display and waits for
events.

This is different than an idle callback because it is only called once, then
FLTK calls the system and tells it not to return until an event happens.

This can be used by code that wants to monitor the application's state, such as
to keep a display up to date. The advantage of using a check callback is that
it is called only when no events are pending. If events are coming in quickly,
whole blocks of them will be processed before this is called once. This can
save significant time and avoid the application falling behind the events.

	add_check( sub { warn 'awake! }, $data  );

You may also store userdata which will be passed along to the callback.

Here's a usage example:

	my $state_changed; # anything that changes the display turns this on

	sub callback {
		return if !$state_changed;
		$state_changed = 0;
		# do_expensive_calculation();
		$widget->redraw();
	}

	Fl::add_check(\&callback);
	Fl::run();


=cut

xs {name        => 'Fl::add_check',
    definitions => [
                  {required => [['SV *', 'coderef'], ['SV *', 'userdata']],
                   returns  => 'void',
                   c_args => '_cb, (void *) new Callback( coderef, userdata )'
                  },
                  {required => [['SV *', 'coderef']],
                   returns  => 'void',
                   c_args   => '_cb, (void *) new Callback( coderef )'
                  }
    ],
    export => ['all']
};
test add_check => sub {

#diag add_awake_handler_( sub {diag 'TEST'}, {test => 'data'} );
#ok (add_awake_handler_( sub {...} ), 'add_awake_handler_(sub { ... })');
#ok (add_awake_handler_( sub {...}, {some => 'data'} ), 'add_awake_handler_(sub { ... }, { some => "data" })');
#diag awake();
    ok(1);
};

=head2 C<add_fd( ... )>

	add_fd( $fh, $when, sub { warn 'awake! }  ); # Kindly gets the fileno for you
	add_fd( fileno($fh), $when, sub { warn 'awake! }  );

Adds file descriptor fd to listen to.

When the fd becomes ready for reading, C<Fl::wait()> will call the callback and
then return. The callback is passed the fd and the arbitrary void* argument.

This version takes a when bitfield, with the bits C<FL_READ>, C<FL_WRITE>, and
C<FL_EXCEPT> defined, to indicate when the callback should be done.

There can only be one callback of each type for a file descriptor.
C<Fl::remove_fd()> gets rid of all the callbacks for a given file descriptor.

Under UNIX/Linux/MacOS any file descriptor can be monitored (files, devices,
pipes, sockets, etc.). Due to limitations in Microsoft Windows, Windows
applications can only monitor sockets.

	add_fd( $fh, $when, sub { warn 'awake! }, $data  ); # Kindly gets the fileno for you
	add_fd( fileno($fh), $when, sub { warn 'awake! }, $data  );

You may also store userdata which will be passed along to the callback.

	add_fd( $fh, sub { warn 'awake! }, $data  ); # Kindly gets the fileno for you
	add_fd( fileno($fh), sub { warn 'awake! }, $data  );
	add_fd( $fh, sub { warn 'awake! } ); # Kindly gets the fileno for you
	add_fd( fileno($fh), sub { warn 'awake! } );

You may listen to a file descriptor without a R/W/Err bitfield as well.

=cut

xs {name        => 'Fl::add_fd',
    definitions => [
        {required => [['int', 'fd'], ['int', 'when'], ['SV *', 'coderef']],
         returns  => 'void',
         c_args   => 'fd, when, _cb_fd, (void *) new Callback( coderef )'
        },
        {required =>
             [['PerlIO *', 'fh'], ['int', 'when'], ['SV *', 'coderef']],
         returns => 'void',
         c_args =>
             'PerlIO_fileno(fh), when, _cb_fd, (void *) new Callback( coderef )'
        },
        {required => [['int',  'fd'],
                      ['int',  'when'],
                      ['SV *', 'coderef'],
                      ['SV *', 'userdata']
         ],
         returns => 'void',
         c_args =>
             'fd, when, _cb_fd, (void *) new Callback( coderef, userdata )'
        },
        {required => [['PerlIO *', 'fh'],
                      ['int',      'when'],
                      ['SV *',     'coderef'],
                      ['SV *',     'userdata']
         ],
         returns => 'void',
         c_args =>
             'PerlIO_fileno(fh), when, _cb_fd, (void *) new Callback( coderef, userdata )'
        },
        {required =>
             [['int', 'fd'], ['SV *', 'coderef'], ['SV *', 'userdata']],
         returns => 'void',
         c_args  => 'fd, _cb_fd, (void *) new Callback( coderef, userdata )'
        },
        {required =>
             [['PerlIO *', 'fh'], ['SV *', 'coderef'], ['SV *', 'userdata']],
         returns => 'void',
         c_args =>
             'PerlIO_fileno(fh), _cb_fd, (void *) new Callback( coderef, userdata )'
        },
        {required => [['int', 'fd'], ['SV *', 'coderef']],
         returns  => 'void',
         c_args   => 'fd, _cb_fd, (void *) new Callback( coderef )'
        },
        {required => [['PerlIO *', 'fh'], ['SV *', 'coderef']],
         returns  => 'void',
         c_args =>
             'PerlIO_fileno(fh), _cb_fd, (void *) new Callback( coderef )'
        },
    ],
    export => ['all']
};
test add_fd => sub {
    my $called = 0;
    #
    my $fh_1 = File::Temp->new(UNLINK => 1, SUFFIX => '.dat');
    add_fd(
        $fh_1, 3,
        sub {
            CORE::state $done;
            return if $done++;
            pass('add_fd($fh, 3, sub {...})');
            $called++;
        }
    );
    #
    my $fh_2 = File::Temp->new(UNLINK => 1, SUFFIX => '.dat');
    add_fd(
        fileno($fh_2),
        3,
        sub {
            CORE::state $done;
            return if $done++;
            pass('add_fd(fileno($fh), 3, sub {...})');
            $called++;
        }
    );
    #
    my $fh_3 = File::Temp->new(UNLINK => 1, SUFFIX => '.dat');
    add_fd(
        $fh_3, 3,
        sub {
            CORE::state $done;
            return if $done++;
            is(shift, \%ENV, 'add_fd($fh, 3, sub {...}, \%ENV)');
            $called++;
        },
        \%ENV
    );
    #
    my $fh_4 = File::Temp->new(UNLINK => 1, SUFFIX => '.dat');
    add_fd(
        fileno($fh_4),
        3,
        sub {
            CORE::state $done;
            return if $done++;
            is(shift, \%ENV, 'add_fd(fileno($fh), 3, sub {...}, \%ENV)');
            $called++;
        },
        \%ENV
    );
    #
    my $fh_5 = File::Temp->new(UNLINK => 1, SUFFIX => '.dat');
    add_fd(
        $fh_5,
        sub {
            CORE::state $done;
            return if $done++;
            pass('add_fd($fh, sub {...})');
            $called++;
        }
    );
    #
    my $fh_6 = File::Temp->new(UNLINK => 1, SUFFIX => '.dat');
    add_fd(
        fileno($fh_6),
        sub {
            CORE::state $done;
            return if $done++;
            pass('add_fd(fileno($fh), sub {...})');
            $called++;
        }
    );
    my $fh_7 = File::Temp->new(UNLINK => 1, SUFFIX => '.dat');
    add_fd(
        $fh_7,
        sub {
            CORE::state $done;
            return if $done++;
            is(shift, \%ENV, 'add_fd($fh, sub {...}, \%ENV)');
            $called++;
        },
        \%ENV
    );
    #
    my $fh_8 = File::Temp->new(UNLINK => 1, SUFFIX => '.dat');
    add_fd(
        fileno($fh_8),
        sub {
            CORE::state $done;
            return if $done++;
            is(shift, \%ENV, 'add_fd(fileno($fh), sub {...}, \%ENV)');
            $called++;
        },
        \%ENV
    );
    #
    my $time = time;
    while ($called < 8) {
        Fl::wait();
        if (time > $time + 5) {
            my $remaining = 8 - $called;
            diag(sprintf 'Timeout waiting for %d callback%s!',
                 $remaining, ($remaining == 1 ? '' : 's'));
            last;
        }
    }
};

=head2 C<add_idle( ... )>

	add_idle(sub {warn 'idle'} );

Adds a callback function that is called every time by C<Fl::wait()> and also
makes it act as though the timeout is zero (this makes C<Fl::wait()> return
immediately, so if it is in a loop it is called repeatedly, and thus the idle
fucntion is called repeatedly).

The idle function can be used to get background processing done.

You can have multiple idle callbacks. To remove an idle callback use
C<Fl::remove_idle()>.

C<Fl::wait()> and C<Fl::check()> call idle callbacks, but C<Fl::ready()> does
not.

The idle callback can call any FLTK functions, including C<Fl::wait()>,
C<Fl::check()>, and C<Fl::ready()>.

FLTK will not recursively call the idle callback.

	add_idle(sub {warn 'idle'}, $data );

You may also pass userdata which will be passed along to the callback.

=cut

xs {name        => 'Fl::add_idle',
    definitions => [
                  {required => [['SV *', 'coderef'], ['SV *', 'userdata']],
                   returns  => 'void',
                   c_args => '_cb, (void *) new Callback( coderef, userdata )'
                  },
                  {required => [['SV *', 'coderef']],
                   returns  => 'void',
                   c_args   => '_cb, (void *) new Callback( coderef )'
                  }
    ],
    export => ['all']
};
test add_idle => sub {
    my $called = 0;
    add_idle(
        sub {
            CORE::state $done;
            return if $done++;
            pass('add_idle(sub{ ... })');
            $called++;
        }
    );
    add_idle(
        sub {
            CORE::state $done;
            return if $done++;
            pass('add_idle(sub{ ... }, \%ENV)');
            $called++;
        },
        \%ENV
    );
    my $time = time;
    while ($called < 2) {
        Fl::wait();
        if (time > $time + 5) {
            my $remaining = 2 - $called;
            diag(sprintf 'Timeout waiting for %d callback%s!',
                 $remaining, ($remaining == 1 ? '' : 's'));
            last;
        }
    }
};

=head2 C<add_timeout( ... )>

	add_timeout( .3, sub {warn 'ding!'} );

	add_timeout( 1.50, sub {warn 'ding!'}, $data );

Adds a one-shot timeout callback.

The function will be called by C<Fl::wait()> at t seconds after this function
is called. The optional argument is passed to the callback.

You can have multiple timeout callbacks. To remove a timeout callback use
C<Fl::remove_timeout()>.

If you need more accurate, repeated timeouts, use C<Fl::repeat_timeout()> to
reschedule the subsequent timeouts.

The following code will print "TICK" each second on stdout with a fair degree
of accuracy:

	use Fl;
    $|++;
    sub callback;    # predefine it for this example!

    sub callback {
        CORE::say 'TICK';
        Fl::repeat_timeout(1.0, \&callback); # retrigger timeout
    }
    my $win = Fl::Window->new( 100, 100 );
    $win->show;
    Fl::add_timeout( 1.0, \&callback );    # set up first timer
    exit Fl::run();

You may also pass userdata which will be passed along to the callback.

=cut

xs {name        => 'Fl::add_timeout',
    definitions => [
            {required =>
                 [['double', 't'], ['SV *', 'coderef'], ['SV *', 'userdata']],
             returns => 'void',
             c_args  => 't, _cb, (void *) new Callback( coderef, userdata )'
            },
            {required => [['double', 't'], ['SV *', 'coderef']],
             returns  => 'void',
             c_args   => 't, _cb, (void *) new Callback( coderef )'
            }
    ],
    export => ['all']
};
test add_timeout => sub {
    my $called = 0;
    add_timeout(
        3,
        sub {
            CORE::state $done;
            fail('add_timeout(3, sub{ ... }) triggered twice!') if $done++;
            fail('add_timeout(3, sub{ ... }) should not trigger first')
                if !$called;
            pass('add_timeout(3, sub{ ... })');
            $called++;
        },
        \%ENV
    );
    add_timeout(
        1,
        sub {
            my ($env) = @_;
            CORE::state $done;
            fail('add_timeout(1, sub{ ... }, \%ENV) triggered twice!')
                if $done++;
            fail('add_timeout(1, sub{ ... }) should trigger first')
                if $called;
            pass('add_timeout(1, sub{ ... }, \%ENV)');
            is($env, \%ENV, 'userdata matches');
            $called++;
        },
        \%ENV
    );
    my $time = time;
    while ($called < 2) {
        Fl::wait();
        if (time > $time + 5) {
            my $remaining = 2 - $called;
            diag(sprintf 'Timeout waiting for %d callback%s!',
                 $remaining, ($remaining == 1 ? '' : 's'));
            last;
        }
    }
};

=head2 C<api_version( )>

	api_version( );

Returns the compiled-in value of the C<FL_API_VERSION> constant.

This is useful for checking the version of a shared library.

=cut

xs {name        => 'Fl::api_version',
    definitions => [{returns => 'int'}],
    export      => ['all']
};
test api_version => sub {
    is(api_version(), FL_API_VERSION, 'api_version( ) == FL_API_VERSION');
};

=head2 C<arg( ... )>

	arg( $argc, @ARGV, $i );

Parse a single switch from C<@ARGV>, starting at word C<$i>.

Returns the number of words eaten (1 or 2, or 0 if it is not recognized) and
adds the same value to C<$i>.

This is the default argument handler used internally by C<Fl::args(...)>, but
you can use this function if you prefer to step through the standard FLTK
switches yourself.

All standard FLTK switches except C<-bg2> may be abbreviated to just one letter
and case is ignored:

=over

=item C<-bg color> or C<-background color>

Sets the background color using C<Fl::background()>.

=item C<-bg2 color> or C<-background2 color>

Sets the secondary background color using C<Fl::background2()>.

=item C<-display host:n.n>

Sets the X display to use; this option is silently ignored under Windows and
MacOS.

=item C<-dnd> and C<-nodnd>

Enables or disables drag and drop text operations using C<Fl::dnd_text_ops()>.

=item C<-fg color> or C<-foreground color>

Sets the foreground color using C<Fl::foreground()>.

=item C<-geometry WxH+X+Y>

Sets the initial window position and size according to the standard X geometry
string.

=item C<-iconic>

Iconifies the window using C<Fl::Window::iconize()>.

=item C<-kbd> and C<-nokbd>

Enables or disables visible keyboard focus for non-text widgets using
C<Fl::visible_focus()>.

=item C<-name string>

Sets the window class using C<Fl::Window::xclass()>.

=item C<-scheme string>

Sets the widget scheme using C<Fl::scheme()>.

=item C<-title string>

Sets the window title using C<Fl::Window::label()>.

=item C<-tooltips> and C<-notooltips>

Enables or disables tooltips using C<Fl::Tooltip::enable()>.

=back

If your program requires other switches in addition to the standard FLTK
options, you will need to pass your own argument handler to C<Fl::args(...r)>
explicitly.

=cut

xs {name        => 'Fl::arg',
    definitions => [
            {required => [['int', 'argc'], ['char **', 'argv'], ['int', 'i']],
             returns  => 'int',
             in_out   => ['i']
            }
    ],
    export => ['all']
};
test arg => sub {
    my $pos = 3;
    {
        my $todo = todo('No idea why these return different values on CI');
        is(arg(2, [qw[-bg2 green]], $pos),
            1, 'Fl::arg(2, [qw[-bg2 green]], $pos)');
        is($pos, 4, '1 value read from stack');
        is(arg(3, [qw[-bg green -bg2 red]], $pos),
            1, 'Fl::arg(2, [qw[-bg green -bg2 red]], $pos)');
        is($pos,                       5, '5 values read from stack');
        is(arg(2, [qw[-bg green]], 0), 0, 'arg(2, [qw[-bg green]], 0)');
    }
};

=head2 C<args( ... )>

	my $ret = args(1, [qw[-my params -go -here -bg red]], 0, sub { ... } ); # $argc, $argv, $i, $cb

Parse command line switches using the your own argument handler.

Returns C<0> on error, or the number of words processed.

FLTK provides this as an entirely optional command line switch parser. You
don't have to call it if you don't want to. Everything it can do can be done
with other calls to FLTK.

To use the switch parser, call C<Fl::args(...)> near the start of your program.
This does not open the display, instead switches that need the display open are
stashed into static variables. Then you must display your first window by
calling C<$window->show(+@ARGV, @ARGV)>, which will do anything stored in the
static variables.

Providing an argument handler callback lets you define your own switches. It is
called with the same C<$argc> and C<$argv>, and with C<$i> set to the index of
the switch to be processed. The handler should return zero if the switch is
unrecognized, and not change C<$i>. It should return non-zero to indicate the
number of words processed if the switch is recognized, i.e. C<1> for just the
switch, and more than C<1> for the switch plus associated parameters. C<i>
should be incremented by the same amount by modifying C<@_>.

The handler is called before any other tests, so you can also override any
standard FLTK switch (this is why FLTK can use very short switches instead of
the long ones all other toolkits force you to use). See C<Fl::arg()> for
descriptions of the standard switches.

On return, C<$i> is set to the index of the first non-switch. This is either:

=over

=item * The first word that does not start with 'C<->'.

=item * The word 'C<->' (used by many programs to name stdin as a file)

=item * The first unrecognized switch (return value is C<0>).

=item * C<@argc>

=back

The return value is C<$i> unless an unrecognized switch is found, in which case
it is zero. If your program takes no arguments other than switches you should
produce an error if the return value is less than argc.

A usage string is displayed if C<Fl::args()> detects an invalid argument on the
command-line. You can change the message by setting the C<Fl::help> pointer.

A very simple command line parser can be found in F<eg/howto-parse-args.pl>.

The simpler C<Fl::args($argc, \@argv)> form is useful if your program does not
have command line switches of its own.

	args(1, [qw[-my params -go -here -bg red]],

Parse all command line switches matching standard FLTK options only.

It parses all the switches, and if any are not recognized it calls
C<Fl::abort(Fl::help)>, i.e. unlike the long form, an unrecognized switch
generates an error message and causes the program to exit.

=cut

xs {name        => 'Fl::args',
    definitions => [{required => [['int', 'argc'], ['char **', 'argv']]},
                    {required =>
                         [['int', 'argc'], ['char **', 'argv'], ['int', 'i']],
                     returns => 'int',
                     in_out  => ['i']
                    },
                    {required => [['int',     'argc'],
                                  ['char **', 'argv'],
                                  ['int',     'i'],
                                  ['SV *',    'cb']
                     ],
                     returns     => 'int',
                     in_out      => ['i'],
                     inject_code => '_cb_args_CODE = new Callback( cb );',
                     c_args      => 'argc, argv, i, _cb_args'
                    }
    ],
    export => ['all']
};
test args => sub {
    my $pos = 0;
    is( args(
            2,
            [qw[-bg2 green]],
            $pos,
            sub {
                pass('args(2, [qw[-bg2 green]], $pos, sub {...}) called');
                $_[2] += 2;
                2;
            }
        ),
        3,
        'arg(2, [qw[-bg2 green]], $pos, sub {...})'
    );
    is($pos, 3, '3 values read from stack');
    is(args(3, [qw[-bg green -dnd]], $pos),
        1, 'args(2, [qw[-bg green -dnd]], $pos)');
    is($pos,                        1, '1 values read from stack');
    is(args(2, [qw[-bg green]], 0), 1, 'arg(2, [qw[-bg green]], 0)');
};

=head2 C<awake( ... )>


=cut

xs {name        => 'Fl::awake',
    definitions => [
                  {returns => 'void',},
                  {required => [['SV *', 'coderef'], ['SV *', 'userdata']],
                   returns  => 'int',
                   c_args => '_cb, (void *) new Callback( coderef, userdata )'
                  },
                  {required => [['SV *', 'coderef']],
                   returns  => 'int',
                   c_args   => '_cb, (void *) new Callback( coderef )'
                  }
    ],
    export => ['all']
};
test awake => sub {

#ok (add_awake_handler_( sub {...} ), 'add_awake_handler_(sub { ... })');
#ok (add_awake_handler_( sub {...}, {some => 'data'} ), 'add_awake_handler_(sub { ... }, { some => "data" })');
    diag(awake());
    ok(1);
};

=head2 C<option( ... )>

	my $enabled = Fl::option( OPTION_ARROW_FOCUS );

Returns a boolean value.

	Fl::option( OPTION_ARROW_FOCUS, 1 );

Enables or disables global FLTK options.

See the C<:option> import tag in L<Fl::Enumerations|Fl::Enumerations>.

=cut

xs {name        => 'Fl::option',
    definitions => [{required =>
                         [['Fl::Fl_Option', 'option'], ['bool', 'value']],
                     returns => 'void'
                    },
                    {required => [['Fl::Fl_Option', 'option']],
                     returns  => 'bool'
                    }
    ],
    export => ['all']
};
test option => sub {
    is Fl::option(Fl::OPTION_ARROW_FOCUS), 0;    # On by default
    Fl::option(Fl::OPTION_ARROW_FOCUS, 1);       # Enable old behavior
};
0 && xs {
    name        => 'Fl::add_fd',
    definitions => [
        {required => [['PerlIO *', 'file'], ['int', 'when'], ['SV *', 'cb']],
         optional => [['SV *',     'data']],
         returns => 'void',
         code    => '',
         cleanup => '',

         # c_args   => 'widget->cp_ctx' # PerlIO_fileno
        }
    ],
    export => [qw[widget]]
};

=pod

=head2 delete_widget(...)

Schedules a widget for deletion at the next call to the event loop.

Use this method to delete a widget inside a callback function.

To avoid early deletion of widgets, this function should be called toward the
end of a callback and only after any call to the event loop (C<Fl::wait()>,
C<Fl::flush()>, C<Fl::check()>, C<fl_ask()>, etc.).

When deleting groups or windows, you must only delete the group or window
widget and not the individual child widgets.

The object reference is undefined after calling this.

=cut

# TODO: Write a test for it as well...
# ----------
xs {name        => 'Fl::delete_widget',
    definitions => [
        {required => [['Fl_Widget *', 'widget']],
         returns  => 'void',
         cleanup =>
             '/*Safefree(widget);*/ SV * sv = (SV *) &PL_sv_undef; sv_setsv(ST(0), sv);',
         c_args => 'widget->cp_ctx'
        }
    ],
    export => [qw[widget]]
};
xs {name        => 'Fl::extends',
    definitions => [
        {required => [['const char *', 'cls']],
         returns  => 'void',
         code     => <<'CODE'
eval_pv("($package, $file, $line, $sub) = caller(0)", TRUE);
//printf("package = %s\n", SvPV_nolen(get_sv("package", 0)));
set_isa(SvPV_nolen(get_sv("package", FALSE)), cls);
// TODO: Add support for draw() and handle()
CODE
        }
    ],
    export => [qw[default]]
};
include 'FL/fl_draw.H';
xs {name        => 'Fl::fl_color',
    definitions => [{required => [['Fl_Color', 'color']],
                     returns  => 'void',
                     code     => 'fl_color(color);'
                    }
    ],
    export => [qw[default draw]]
};
xs {name        => 'Fl::fl_line',
    definitions => [
        {required => [[qw[int x1]], [qw[int y1]], [qw[int x2]], [qw[int y2]]],
         returns  => 'void',
         code     => 'fl_line(x1, y1, x2, y2);'
        }
    ],
    export => [qw[default draw]]
};
xs {name        => 'Fl::fl_rect',
    definitions => [
            {required => [[qw[int x]], [qw[int y]], [qw[int w]], [qw[int h]]],
             returns  => 'void',
             code     => 'fl_rect(x, y, w, h);'
            }
    ],
    export => [qw[default draw]]
};
xs {name        => 'Fl::fl_rectf',
    definitions => [
            {required => [[qw[int x]], [qw[int y]], [qw[int w]], [qw[int h]]],
             returns  => 'void',
             code     => 'fl_rectf(x, y, w, h);'
            }
    ],
    export => [qw[default draw]]
};

=pod

=head1 LICENSE

Copyright (C) 2020 Sanko Robinson

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=head1 AUTHOR

Sanko Robinson E<lt>sanko@cpan.orgE<gt>

=cut
